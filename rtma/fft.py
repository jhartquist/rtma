# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fft.ipynb (unless otherwise specified).

__all__ = ['is_power_of_two', 'zero_phase_buffer', 'fft_analysis', 'fft_synthesis']

# Cell
from .imports import *
from .signal import *

# Cell
def is_power_of_two(n: int) -> bool:
    return n > 1 and (n & (n-1)) == 0

# Cell
def zero_phase_buffer(x: np.ndarray,
                      n_fft: Optional[int] = None,
                      n_window: Optional[int] = None,
                      forward: bool = True):
    x = np.array(x) # signal to be a list
    n_signal = x.shape[0]
    if forward:
        if n_fft:
            assert n_fft >= n_signal, 'n_fft must be >= the number of samples'
            assert is_power_of_two(n_fft), 'n_fft must be a power of two'
            buffer = np.zeros(n_fft, dtype=x.dtype)
        else:
            buffer = np.zeros_like(x, dtype=x.dtype)

        center_i = n_signal // 2
        x_left  = x[:center_i]  # always even length, does not include center sample
        x_right = x[center_i:] # odd if signal length is odd, otherwise even

        buffer[:x_right.size] = x_right  # placed on the left
        buffer[-x_left.size:] = x_left   # placed on the right, at the end
        return buffer

# Cell
def fft_analysis(x, n_fft, thresh = 1e-14):
    assert x.size <= n_fft
    assert is_power_of_two(n_fft)

    pos_n_fft = (n_fft // 2) + 1

    fft_buffer = zero_phase_buffer(x, n_fft=n_fft)
    X = np.fft.rfft(fft_buffer)[:pos_n_fft]

    magnitude = abs(X)

    X.real[abs(X.real) < thresh] = 0.0
    X.imag[abs(X.imag) < thresh] = 0.0
    phase = np.unwrap(np.angle(X))

    return magnitude, phase

# Cell
def fft_synthesis(m_x, p_x, m):
    assert m_x.shape == p_x.shape

    pos_n_fft = m_x.size
    n_fft = (pos_n_fft - 1) * 2
    assert is_power_of_two(n_fft)

    Y = m_x * np.exp(1j * p_x)
    fft_buffer = np.fft.irfft(Y)

    m1 = m // 2
    m2 = (m+1) // 2

    y = np.zeros(m)
    y[:m1] = fft_buffer[-m1:]
    y[m1:] = fft_buffer[:m2]

    return y