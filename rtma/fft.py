# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_fft.ipynb (unless otherwise specified).

__all__ = ['EPSILON', 'is_power_of_two', 'zero_phase_buffer', 'amplitude_to_decibels', 'decibels_to_amplitude',
           'fft_analysis', 'fft_synthesis']

# Cell
from .imports import *
from .signal import *

# Cell
EPSILON = np.finfo(float).eps

# Cell
def is_power_of_two(n: int) -> bool:
    return n > 1 and (n & (n-1)) == 0

# Cell
def zero_phase_buffer(x_or_buffer: np.ndarray,
                      n_fft: Optional[int] = None,
                      n_window: Optional[int] = None,
                      reverse: bool = False):
    x_or_buffer = np.array(x_or_buffer) # signal to be a list
    n_samples = x_or_buffer.shape[0]

    if reverse:
        buffer = x_or_buffer

        if n_window is None:
            n_window = n_samples

        center_i = n_window // 2
        x_left  = buffer[-center_i:]          # from the right side of buffer
        x_right = buffer[:n_window-center_i]  # from the left side of buffer

        x = np.concatenate([x_left, x_right])
        assert x.shape[0] == n_window
        return x

    else:
        x = x_or_buffer

        if n_fft:
            assert n_fft >= n_samples, 'n_fft must be >= the number of samples'
            assert is_power_of_two(n_fft), 'n_fft must be a power of two'
            buffer = np.zeros(n_fft, dtype=x.dtype)
        else:
            buffer = np.zeros_like(x, dtype=x.dtype)

        center_i = n_samples // 2
        x_left  = x[:center_i]  # always even length, does not include center sample
        x_right = x[center_i:] # odd if signal length is odd, otherwise even

        buffer[:x_right.size] = x_right  # placed on the left
        buffer[-x_left.size:] = x_left   # placed on the right, at the end
        return buffer

# Cell

def amplitude_to_decibels(x: np.ndarray) -> np.ndarray:
    x = x.copy()
    x[x < EPSILON] = EPSILON
    x_db = 20.0 * np.log10(x)
    return x_db

# Cell

def decibels_to_amplitude(x: np.ndarray) -> np.ndarray:
    x = 10.0 ** (x / 20.0)
    return x

# Cell

def fft_analysis(x, n_fft, decibels=True, thresh = 1e-14):
    assert x.size <= n_fft
    assert is_power_of_two(n_fft)

    pos_n_fft = (n_fft // 2) + 1

    fft_buffer = zero_phase_buffer(x, n_fft=n_fft)
    X = np.fft.rfft(fft_buffer)[:pos_n_fft]

    m_x = abs(X)
    if decibels:
        m_x = amplitude_to_decibels(m_x)

    X.real[abs(X.real) < thresh] = 0.0
    X.imag[abs(X.imag) < thresh] = 0.0
    p_x = np.unwrap(np.angle(X))

    return m_x, p_x

# Cell
def fft_synthesis(m_x, p_x, m, decibels=True):
    assert m_x.shape == p_x.shape

    pos_n_fft = m_x.size
    n_fft = (pos_n_fft - 1) * 2
    assert is_power_of_two(n_fft)

    if decibels:
        m_x = decibels_to_amplitude(m_x)

    Y = m_x * np.exp(1j * p_x)
    fft_buffer = np.fft.irfft(Y)
    y = zero_phase_buffer(fft_buffer, n_window=m, reverse=True)

    return y