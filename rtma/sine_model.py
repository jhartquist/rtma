# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_sine_model.ipynb (unless otherwise specified).

__all__ = ['detect_peaks', 'plot_peaks', 'interpolate_peaks', 'plot_ipeaks', 'synth_window', 'Frame',
           'sine_model_analysis', 'synth_window', 'sine_model_synthesis']

# Cell
from .imports import *
from .core import *
from .signal import *
from .fft import *
from .stft import *

# Cell
def detect_peaks(x, thresh):
    # first and last cannot be peaks
    above_thresh = np.greater(x[1:-1], thresh)
    gt_before = np.greater(x[1:-1], x[:-2])
    gt_after =  np.greater(x[1:-1], x[2:])
    is_peak = above_thresh & gt_before & gt_after
    peaks_i = is_peak.nonzero()[0] + 1
    return peaks_i

# Cell
def plot_peaks(x, peak_i, t=None):
    plt.figure(figsize=(10, 6))
    plt.plot(x)
    plt.plot(peak_i, x[peak_i], marker='x', color='r', linestyle='', markeredgewidth=1.5)
    if t is not None:
        plt.axhline(t, c='g')

# Cell
def interpolate_peaks(mags, peak_i):
    a, b, c = mags[peak_i-1], mags[peak_i], mags[peak_i+1]
    ipeak_i = peak_i + 0.5 * (a - c) / (a - 2*b + c)
    ipeak_mags = b - 0.25 * (a - c) * (ipeak_i - peak_i)
    return ipeak_i, ipeak_mags

# Cell
def plot_ipeaks(mags, ipeak_i, ipeak_mag, peak_i=None, t=None):
    plt.figure(figsize=(10, 6))
    plt.plot(mags)
    plt.plot(ipeak_i, ipeak_mag, marker='x', color='g', linestyle='', markeredgewidth=1.5)
    if peak_i is not None:
        plt.plot(peak_i, mags[peak_i], marker='x', color='r', linestyle='', markeredgewidth=1.5)
    if t is not None:
        plt.axhline(t, c='g')

# Cell
def synth_window(n_fft: int) -> np.ndarray:
    h = n_fft // 4
    t_win = triang(2 * h)
    t_win = np.pad(t_win, (h, h), mode='constant')
    bh_win = blackmanharris(n_fft)
    bh_win /= bh_win.sum()
    win = t_win / bh_win
    return win

# Cell
class Frame:
    def __init__(self, freqs=None, mags=None, phases=None):
        self.freqs = freqs
        self.mags = mags
        self.phases = phases

    def __len__(self):
        return self.freqs.size

# Cell
def sine_model_analysis(x, fs, w, n_fft, h, t):
    frames = []
    for frame_i, (mx, px) in enumerate(stft(x, n_fft, h, w)):
        mx_db = 20.0 * np.log10(mx)
        peak_i = detect_peaks(mx_db, t)
        ipeak_i, ipeak_m = interpolate_peaks(mx_db, peak_i)
        ipeak_p = np.interp(ipeak_i, np.arange(px.size), px)
        ipeak_f = fs * ipeak_i / n_fft

        frame = Frame(ipeak_f, ipeak_m, ipeak_p)
        frames.append(frame)

    return frames

# Cell
def synth_window(n_fft: int, h: int) -> np.ndarray:
    t_win = triang(2 * h)
    padding = (n_fft - 2*h) // 2
    t_win = np.pad(t_win, (padding, padding), mode='constant')
    bh_win = blackmanharris(n_fft)
    bh_win /= bh_win.sum()
    win = t_win / bh_win
    return win

# Cell
def sine_model_synthesis(frames, n_fft, h, fs):
    n_frames = len(frames)
    y_length = h*(n_frames - 1) + n_fft
    y = np.zeros(y_length)

    synth_win = synth_window(n_fft, h)

    for i, f in enumerate(frames):
        Y = generate_sine_spectrum(f.freqs, f.mags, f.phases, n_fft, fs)
        fft_buffer = np.real(np.fft.ifft(Y))
        yw = zero_phase_buffer(fft_buffer, n_window=n_fft, reverse=True)
        offset = i*h
        y[offset:offset+n_fft] += synth_win * yw

    return y
