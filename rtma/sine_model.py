# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_sine_model.ipynb (unless otherwise specified).

__all__ = ['detect_peaks', 'plot_peaks', 'interpolate_peaks', 'plot_ipeaks', 'synth_window', 'Frame', 'sine_tracking',
           'clean_sine_tracks', 'sine_model_analysis']

# Cell
from .imports import *
from .core import *
from .signal import *
from .fft import *
from .stft import *

# Cell
def detect_peaks(x: np.ndarray, thresh: float) -> np.ndarray:
    # first and last cannot be peaks
    above_thresh = np.greater(x[1:-1], thresh)
    gt_before = np.greater(x[1:-1], x[:-2])
    gt_after =  np.greater(x[1:-1], x[2:])
    is_peak = above_thresh & gt_before & gt_after
    peaks_i = is_peak.nonzero()[0] + 1
    return peaks_i

# Cell
def plot_peaks(x, peak_i, t=None):
    plt.figure(figsize=(10, 6))
    plt.plot(x)
    plt.plot(peak_i, x[peak_i], marker='x', color='r', linestyle='', markeredgewidth=1.5)
    if t is not None:
        plt.axhline(t, c='g')

# Cell
def interpolate_peaks(mags, peak_i):
    a, b, c = mags[peak_i-1], mags[peak_i], mags[peak_i+1]
    ipeak_i = peak_i + 0.5 * (a - c) / (a - 2*b + c)
    ipeak_mags = b - 0.25 * (a - c) * (ipeak_i - peak_i)
    return ipeak_i, ipeak_mags

# Cell
def plot_ipeaks(mags, ipeak_i, ipeak_mag, peak_i=None, t=None):
    plt.figure(figsize=(10, 6))
    plt.plot(mags)
    plt.plot(ipeak_i, ipeak_mag, marker='x', color='g', linestyle='', markeredgewidth=1.5)
    if peak_i is not None:
        plt.plot(peak_i, mags[peak_i], marker='x', color='r', linestyle='', markeredgewidth=1.5)
    if t is not None:
        plt.axhline(t, c='g')

# Cell
def synth_window(n_fft: int) -> np.ndarray:
    h = n_fft // 4
    t_win = triang(2 * h)
    t_win = np.pad(t_win, (h, h), mode='constant')
    bh_win = blackmanharris(n_fft)
    bh_win /= bh_win.sum()
    win = t_win / bh_win
    return win

# Cell
class Frame:
    def __init__(self, freqs=None, mags=None, phases=None):
        self.freqs = freqs
        self.mags = mags
        self.phases = phases

    def __len__(self):
        return self.freqs.size

# Cell

def sine_tracking(frame: Frame,
                  tfreq,
                  freq_dev_offset=20,
                  freq_dev_slope=0.01):
    #print('--------')

    tfreq_out = np.zeros(tfreq.size)
    tmag_out = np.zeros(tfreq.size)
    tphase_out = np.zeros(tfreq.size)

    cur_i = np.arange(frame.freqs.size)
    prev_i = np.arange(tfreq.size)  # incomingTracks
    new_i = np.zeros(tfreq.size, dtype=np.int) - 1
    mag_order = np.argsort(-frame.mags)

    tmp_freq = np.copy(frame.freqs)
    tmp_mag = np.copy(frame.mags)
    tmp_phase = np.copy(frame.phases)

    #print("tfreq", tfreq, ' tmp_freq', tmp_freq)


    # continue tracks


    if prev_i.size > 0:
        for i in mag_order:
            if prev_i.size == 0: break

            track = np.argmin(abs(tmp_freq[i] - tfreq[prev_i]))
            freq_dist = abs(tmp_freq[i] - tfreq[prev_i[track]])
            #print(f'  i: {i}, track: {track}, dist: {freq_dist}')
            thresh = (freq_dev_offset + freq_dev_slope * tmp_freq[i])
            if freq_dist < thresh:
                new_i[prev_i[track]] = i
                prev_i = np.delete(prev_i, track)

    #print('new_i', new_i)
    index_t = np.array(np.nonzero(new_i != -1), dtype=np.int)[0]  # empty for now
    #print('index_t', index_t)
    if index_t.size > 0:
        index_p = new_i[index_t]
        tfreq_out[index_t] = tmp_freq[index_p]
        tmag_out[index_t] = tmp_mag[index_p]
        tphase_out[index_t] = tmp_phase[index_p]

        tmp_freq = np.delete(tmp_freq, index_p)
        tmp_mag = np.delete(tmp_mag, index_p)
        tmp_phase = np.delete(tmp_phase, index_p)

    #print(tfreq)
    empty_t = np.array(np.nonzero(tfreq == 0), dtype=np.int)[0] # indexes of empty incoming tracks
    #print(empty_t)
    n_empty = empty_t.size

    peaks_left = np.argsort(-tmp_mag)
    #print(f'peaks_left: {peaks_left.size}, n_empty: {n_empty}')


    # create new tracks

    if ((peaks_left.size > 0) & (n_empty >= peaks_left.size)):
        idx = empty_t[:peaks_left.size]
        tfreq_out[idx] = tmp_freq[peaks_left]
        tmag_out[idx] = tmp_mag[peaks_left]
        tphase_out[idx] = tmp_phase[peaks_left]

    elif ((peaks_left.size > 0) & (n_empty < peaks_left.size)):
        idx = peaks_left[:empty_t.size]
        tfreq_out[empty_t]  = tmp_freq[idx]
        tmag_out [empty_t]  = tmp_mag[idx]
        tphase_out[empty_t] = tmp_phase[idx]

        idx = peaks_left[empty_t.size:]
        tfreq_out  = np.append(tfreq_out,  tmp_freq[idx])
        tmag_out   = np.append(tmag_out,   tmp_mag[idx])
        tphase_out = np.append(tphase_out, tmp_phase[idx])

    return Frame(tfreq_out, tmag_out, tphase_out)

# Cell
def clean_sine_tracks(freqs, min_track_length=3):
    n_frames, n_tracks = freqs.shape
    for t in range(n_tracks):
        track_freqs = freqs[:, t]

        # zero followed by a nonzero
        track_begs = np.nonzero(
            (track_freqs[:-1] <= 0) & (track_freqs[1:] > 0)
        )[0] + 1

        # first track is a nonzero, so also a beginning
        if track_freqs[0] > 0:
            track_begs = np.insert(track_begs, 0, 0)

        track_ends = np.nonzero(
            (track_freqs[:-1] > 0) & (track_freqs[1:] <= 0)
        )[0] + 1
        if track_freqs[-1] > 0:
            track_ends = np.append(track_ends, n_frames-1)

        track_lengths = track_ends - track_begs + 1
        for t_beg, t_len in zip(track_begs, track_lengths):
            if t_len <= min_track_length:
                track_freqs[t_beg:t_beg+t_len] = 0
    return freqs

# Cell
def sine_model_analysis(x, sr, w,
                 n_fft, n_hop, t,
                 max_n_sines,
                 min_sine_duration,
                 pad_center=False,
                 freq_dev_offset=20,
                 freq_dev_slope=0.01):
    frames = []

    tfreq = np.array([])

    for frame_i, (mx, px) in enumerate(stft(x, n_fft, n_hop, w, pad_center=pad_center)):
        peak_i = detect_peaks(mx, t)
        ipeak_i, ipeak_m = interpolate_peaks(mx, peak_i)
        ipeak_p = np.interp(ipeak_i, np.arange(px.size), px)
        ipeak_f = sr * ipeak_i / n_fft

        frame = Frame(ipeak_f, ipeak_m, ipeak_p)
        tframe = sine_tracking(frame, tfreq,
                               freq_dev_offset=freq_dev_offset,
                               freq_dev_slope=freq_dev_slope)
        frames.append(tframe)
        tfreq = tframe.freqs

    padded = np.stack([np.pad(f.freqs, (0, max_n_sines-f.freqs.size), 'constant')
                       for f in frames])
    min_sine_frames = round(sr * min_sine_duration / n_hop)
    freqs = clean_sine_tracks(padded, min_sine_frames)

    return freqs